
涉及到MST问题时，一个常见的思路就是先求出原图的MST，然后在MST上进行加边或删边操作，常见的套路就是利用LCA倍增的方法求树上任意两点之间的最值。

## 问题一

### 链接

http://codeforces.com/problemset/problem/609/e

### 描述

给一个n个点m条边，无重边无自环的图，对于每一条边，求包含这条边的最小可能的生成树。

### 分析

先求出原图的最小生成树， 再考虑加边。 在MST上加一条边必然构成环， 要是包含新加的边的生成树最小， 则必须删去环中最大的边。

### Submission

http://codeforces.com/contest/609/submission/28609380

## 问题二

### 链接

http://codeforces.com/contest/828/problem/F

### 描述

给一个n个点m条边，无重边无自环的图，若独立改变每一条边的权值，也就是修改一条边时其他边保持不变，

求对于每一条边而言，能够成为最小生成树中的边时该边的最大权值。

### 分析

首先求出原图的MST，那么现在所有的边就能分成两类： 不在树上和在树上。

对于case 1：

在求得的MST上添加该边必然导致出现环，而要保证添加的边能留下，那么该边的最大权值必然小于环中最大边的权值， 也即树上两点间最大边长。

对于case 2：

由于添加的边原本就在MST上，通过MST生成的过程我们可以看出，增加该边(假设为u,v)的权值时，如果该边能够被其他边替换掉，

那么必然存在一条边连接包含u的连通块和包含v的连通块，并且权值比(u,v)小。

所以（u,v）能够取得的最大值就是连接两端点分别构成的连通块的边的最小值-1.

具体实现时，如果仅按上述想法朴素的进行实现，重复的求连通块必然导致复杂度过高。

所以我们可以先对所有边进行排序，从小到大遍历边，对于case 1，直接查询LCA； 对于case 2，由于当前枚举的边就是最小的边，

所以该边对应MST上的两个节点之间的所有边能取得的最大权值就是该边的权值-1.

### Submission

http://codeforces.com/contest/828/submission/28667584
